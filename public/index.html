<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&family=Lato:wght@400;700&display=swap">
    <style>
        * {
            margin: 0;
            padding: 0;

            box-sizing: border-box;
        }

        body {
            text-align: center;
        }

        canvas {
            width: 1280px;
            height: 768px;
            background-color: #240254;
        }
    </style>
</head>

<body>
<script>
    var __PROD=false,core={}
"use strict";
"use strict";
var CoreVec2 = (function () {
    function CoreVec2(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.x = x;
        this.y = y;
    }
    CoreVec2.prototype.get_length = function () {
        return Math.hypot(this.x, this.y);
    };
    CoreVec2.prototype.get_direction_rad = function () {
        return Math.atan2(this.y, this.x);
    };
    CoreVec2.prototype.get_direction_deg = function () {
        return this.get_direction_rad() * CoreVec2.RAD_TO_DEG;
    };
    CoreVec2.prototype.set = function (x, y) {
        if (x instanceof CoreVec2) {
            y = x.y;
            x = x.x;
        }
        this.x = x;
        this.y = (typeof y === 'undefined' ? this.y : y);
        return this;
    };
    CoreVec2.prototype.add = function (x, y) {
        if (x instanceof CoreVec2) {
            y = x.y;
            x = x.x;
        }
        this.x += x;
        this.y += (typeof y === 'undefined' ? this.y : y);
        return this;
    };
    CoreVec2.prototype.dot = function (v) {
        return this.get_length() * v.get_length() * Math.cos(this.get_direction_rad() * v.get_direction_rad());
    };
    CoreVec2.prototype.reset = function () {
        this.set(0, 0);
    };
    CoreVec2.prototype.lerp_to = function (target, t) {
        if (t === void 0) { t = 0.1; }
        this.x += (target.x - this.x) * t;
        this.y += (target.y - this.y) * t;
    };
    CoreVec2.polar = function (magnitude, direction_deg) {
        direction_deg = direction_deg * CoreVec2.DEG_TO_RAD;
        return new CoreVec2(magnitude * Math.cos(direction_deg), magnitude * Math.sin(direction_deg));
    };
    CoreVec2.RAD_TO_DEG = 180 / Math.PI;
    CoreVec2.DEG_TO_RAD = Math.PI / 180;
    CoreVec2.one = new CoreVec2(1, 1);
    CoreVec2.zero = new CoreVec2(0, 0);
    CoreVec2.half = new CoreVec2(0.5, 0.5);
    return CoreVec2;
}());
"use strict";
"use strict";
core.stage = {
    pixel_ratio: 2,
    w: 300,
    h: 150,
    mid: {
        w: 150,
        h: 75,
    },
    canvas: document.createElement('canvas'),
    setup: function () {
        var _this = this;
        window.addEventListener('resize', function () { return _this.resize_event(); });
    },
    apply_pixel_ratio: function () {
        var ctx = this.canvas.getContext('2d');
        var redraw_canvas = document.createElement('canvas');
        if (this.canvas.width > 0 && this.canvas.height > 0) {
            redraw_canvas.width = this.canvas.width;
            redraw_canvas.height = this.canvas.height;
            redraw_canvas.getContext('2d').drawImage(this.canvas, 0, 0);
        }
        this.canvas.width = this.w * this.pixel_ratio;
        this.canvas.height = this.h * this.pixel_ratio;
        ctx.resetTransform();
        ctx.drawImage(redraw_canvas, 0, 0);
        ctx.scale(this.pixel_ratio, this.pixel_ratio);
    },
    resize_event: function () {
        var b = this.canvas.getBoundingClientRect();
        this.w = b.width;
        this.h = b.height;
        this.mid.w = this.w / 2;
        this.mid.h = this.h / 2;
        this.apply_pixel_ratio();
    },
    clear: function () {
        this.canvas.getContext('2d').clearRect(0, 0, this.w, this.h);
    },
    get_random_x: function (margin) {
        if (margin === void 0) { margin = 0; }
        return margin + (this.w - margin * 2) * Math.random();
    },
    get_random_y: function () {
        return this.h * Math.random();
    },
};
"use strict";
var CORE_INPUT_KEYCODES = [
    'KeyU',
];
var CoreInputKey = (function () {
    function CoreInputKey(id) {
        this.is_held = false;
        this.is_pressed = false;
        this.is_released = false;
        this.id = id;
    }
    CoreInputKey.prototype.up = function () {
        this.is_held = false;
        this.is_released = true;
    };
    CoreInputKey.prototype.down = function () {
        if (!this.is_held) {
            this.is_held = true;
            this.is_pressed = true;
        }
    };
    CoreInputKey.prototype.reset = function () {
        this.is_pressed = false;
        this.is_released = false;
    };
    return CoreInputKey;
}());
core.input = {
    DEFAULT_MOVING_TIMEOUT: 100,
    x: 0,
    y: 0,
    mouse_x: 0,
    mouse_y: 0,
    position: {
        x: 0,
        y: 0,
    },
    is_moving_timeout_done: true,
    is_mouse_moving: false,
    mouses: [],
    keys: {},
    setup: function () {
        var _this = this;
        for (var i = 0; i < 5; i++) {
            this.mouses.push(new CoreInputKey(i));
        }
        for (var _i = 0, CORE_INPUT_KEYCODES_1 = CORE_INPUT_KEYCODES; _i < CORE_INPUT_KEYCODES_1.length; _i++) {
            var code = CORE_INPUT_KEYCODES_1[_i];
            this.keys[code] = new CoreInputKey(code);
        }
        window.addEventListener('mouseup', function (e) {
            _this.mouses[e.button].up();
            _this.update_mouse(e);
        });
        window.addEventListener('mousedown', function (e) {
            _this.mouses[e.button].down();
            _this.update_mouse(e);
        });
        window.addEventListener('mousemove', function (e) {
            _this.update_mouse(e);
            _this.is_moving_timeout_done = false;
            _this.is_mouse_moving = true;
            window.setTimeout(function () { return _this.is_moving_timeout_done = true; }, _this.DEFAULT_MOVING_TIMEOUT);
        });
        window.addEventListener('keyup', function (e) {
            if (_this.keys[e.code])
                _this.keys[e.code].up();
        });
        window.addEventListener('keydown', function (e) {
            if (_this.keys[e.code])
                _this.keys[e.code].down();
        });
    },
    set_position: function (x, y) {
        this.x = x;
        this.y = y;
        this.position.x = this.x;
        this.position.y = this.y;
    },
    set_mouse_position: function (x, y) {
        this.mouse_x = x;
        this.mouse_y = y;
        this.set_position(this.mouse_x, this.mouse_y);
    },
    update_mouse: function (e) {
        var b = core.stage.canvas.getBoundingClientRect();
        this.set_mouse_position(e.clientX - b.x, e.clientY - b.y);
    },
    mouse_up: function (button) {
        return this.mouses[button].is_released;
    },
    mouse_down: function (button) {
        return this.mouses[button].is_pressed;
    },
    mouse_hold: function (button) {
        return this.mouses[button].is_held;
    },
    key_up: function (code) {
        return this.keys[code].is_released;
    },
    key_down: function (code) {
        return this.keys[code].is_pressed;
    },
    key_hold: function (code) {
        return this.keys[code].is_held;
    },
    reset: function () {
        this.mouses.forEach(function (n) { return n.reset(); });
        for (var code in this.keys) {
            this.keys[code].reset();
        }
        if (this.is_moving_timeout_done) {
            this.is_mouse_moving = false;
        }
    },
};
"use strict";
core.time = {
    t: 0,
    dt: 0,
    last_time: 0,
    fps: 0,
    scaled_dt: 0,
    update: function (t) {
        this.last_time = this.t;
        this.t = t;
        this.dt = this.t - this.last_time;
        this.fps = 1000 / this.dt;
        this.scaled_dt = this.dt / (1000 / 60);
    },
};
"use strict";
var CoreFont = (function () {
    function CoreFont(size, style, family) {
        this.size = size;
        this.style = style;
        this.family = family;
    }
    return CoreFont;
}());
"use strict";
core.draw = {
    TWO_PI: 2 * Math.PI,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    ctx: core.stage.canvas.getContext('2d'),
    text_height: 10,
    images: {},
    strips: {},
    set_color: function (fill, stroke) {
        this.ctx.fillStyle = fill;
        this.ctx.strokeStyle = stroke || fill;
    },
    set_font: function (font, overrides) {
        if (overrides === void 0) { overrides = {}; }
        var style = (typeof overrides.style === 'undefined' ? font.style : overrides.style);
        this.ctx.font = "".concat(style).concat(style ? ' ' : '').concat(overrides.size || font.size, "px ").concat(overrides.family || font.family, ", serif");
        this.text_height = overrides.size || font.size;
    },
    set_halign: function (align) {
        this.ctx.textAlign = align;
    },
    set_valign: function (align) {
        this.ctx.textBaseline = align;
    },
    set_hvalign: function (halign, valign) {
        this.ctx.textAlign = halign;
        this.ctx.textBaseline = valign;
    },
    split_text: function (text) {
        return ('' + text).split('\n');
    },
    text: function (x, y, text) {
        var baseline = 0;
        var t = this.split_text(text);
        switch (this.ctx.textBaseline) {
            case 'bottom':
                baseline = -this.text_height * (t.length - 1);
                break;
            case 'middle':
                baseline = -this.text_height * (t.length - 1) * 0.5;
                break;
        }
        for (var i = t.length - 1; i >= 0; --i) {
            this.ctx.fillText(t[i], x, y + baseline + this.text_height * i);
        }
    },
    get_text_width: function (text) {
        var _this = this;
        return Math.max.apply(Math, this.split_text(text).map(function (x) { return _this.ctx.measureText(x).width; }));
    },
    get_text_height: function (text) {
        return this.text_height * this.split_text(text).length;
    },
    add_image: function (origin, name, image) {
        this.images[name] = {
            origin: origin,
            image: image,
        };
        return this.images[name].image;
    },
    add_strip: function (origin, name, image, image_number, image_per_row) {
        image_per_row = image_per_row || image_number;
        var image_width = image.width / image_per_row;
        var image_height = image.height / (image_number / image_per_row);
        this.strips[name] = {
            origin: origin,
            image: image,
            image_number: image_number,
            image_per_row: image_per_row,
            image_width: image_width,
            image_height: image_height,
        };
        return this.strips[name].image;
    },
    set_alpha: function (a) {
        this.ctx.globalAlpha = a;
    },
    reset_alpha: function () {
        this.ctx.globalAlpha = 1;
    },
    image_el: function (img, x, y, origin) {
        if (origin === void 0) { origin = CoreVec2.half; }
        x -= img.width * origin.x;
        y -= img.height * origin.y;
        this.ctx.drawImage(img, x, y);
    },
    image: function (name, x, y) {
        var img = this.images[name];
        this.image_el(img.image, x, y, img.origin);
    },
    strip: function (name, image_index, x, y) {
        var img = this.strips[name];
        image_index = image_index % img.image_number;
        x -= img.image_width * img.origin.x;
        y -= img.image_height * img.origin.y;
        this.ctx.drawImage(img.image, (image_index % img.image_per_row) * img.image_width, Math.floor(image_index / img.image_per_row) * img.image_height, img.image_width, img.image_height, x, y, img.image_width, img.image_height);
    },
    draw: function (is_stroke) {
        if (is_stroke === void 0) { is_stroke = false; }
        is_stroke ? this.ctx.stroke() : this.ctx.fill();
    },
    line: function (x1, y1, x2, y2) {
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.closePath();
        this.ctx.stroke();
    },
    rect: function (x, y, w, h, is_stroke) {
        if (is_stroke === void 0) { is_stroke = false; }
        this.ctx.beginPath();
        this.ctx.rect(x, y, w, h);
        this.draw(is_stroke);
    },
    circle: function (x, y, r, is_stroke) {
        if (is_stroke === void 0) { is_stroke = false; }
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, this.TWO_PI);
        this.draw(is_stroke);
    },
    on_transform: function (x, y, xscale, yscale, angle_deg, draw_fn) {
        this.ctx.save();
        this.ctx.translate(x, y);
        this.ctx.rotate(angle_deg * this.DEG_TO_RAD);
        this.ctx.scale(xscale, yscale);
        draw_fn();
        this.ctx.restore();
    },
    image_transformed: function (name, x, y, xscale, yscale, angle_deg) {
        var _this = this;
        this.on_transform(x, y, xscale, yscale, angle_deg, function () { return _this.image(name, 0, 0); });
    },
    image_rotated: function (name, x, y, angle_deg) {
        this.image_transformed(name, x, y, 1, 1, angle_deg);
    },
    image_ext: function (name, x, y, xscale, yscale, angle_deg, alpha) {
        this.set_alpha(alpha);
        this.image_transformed(name, x, y, xscale, yscale, angle_deg);
        this.reset_alpha();
    },
    strip_transformed: function (name, image_index, x, y, xscale, yscale, angle_deg) {
        var _this = this;
        this.on_transform(x, y, xscale, yscale, angle_deg, function () { return _this.strip(name, image_index, 0, 0); });
    },
    strip_rotated: function (name, image_index, x, y, angle_deg) {
        this.strip_transformed(name, image_index, x, y, 1, 1, angle_deg);
    },
    strip_ext: function (name, image_index, x, y, xscale, yscale, angle_deg, alpha) {
        this.set_alpha(alpha);
        this.strip_transformed(name, image_index, x, y, xscale, yscale, angle_deg);
        this.reset_alpha();
    },
};
"use strict";
var CoreScene = (function () {
    function CoreScene() {
        this.is_auto_clear_stage = true;
        this.is_obj_update_disabled = false;
        this.is_obj_render_disabled = false;
    }
    CoreScene.prototype.start = function () { };
    CoreScene.prototype.update = function () { };
    CoreScene.prototype.render = function () { };
    CoreScene.prototype.render_ui = function () { };
    return CoreScene;
}());
core.scene = {
    DUMMY_SCENE: new CoreScene(),
    current_scene: null,
    previous_scene: null,
    change_scene: function (new_scene) {
        this.previous_scene = this.current_scene;
        this.current_scene = new_scene;
        if (this.current_scene !== this.previous_scene) {
            this.restart();
        }
    },
    restart: function () {
        this.current_scene.start();
    },
    update: function () {
        this.current_scene.update();
    },
    render: function () {
        this.current_scene.render();
    },
    render_ui: function () {
        this.current_scene.render_ui();
    },
};
core.scene.current_scene = core.scene.DUMMY_SCENE;
core.scene.previous_scene = core.scene.DUMMY_SCENE;
"use strict";
var CoreObject = (function () {
    function CoreObject(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.id = 0;
        this.depth = 0;
        this.is_active = true;
        this.is_visible = true;
        this.x = x;
        this.y = y;
    }
    CoreObject.prototype.start = function () { };
    CoreObject.prototype.pre_update = function () { };
    CoreObject.prototype.update = function () { };
    CoreObject.prototype.post_update = function () { };
    CoreObject.prototype.inactive_update = function () { };
    CoreObject.prototype.render = function () { };
    CoreObject.prototype.render_ui = function () { };
    return CoreObject;
}());
core.obj = {
    _ID: 0,
    names: [],
    instances: [],
    add_name: function (name) {
        this.instances.push([]);
        return this.names.push(name) - 1;
    },
    get_index: function (name) {
        return this.names.indexOf(name);
    },
    update_all: function () {
        for (var i = this.instances.length - 1; i >= 0; i--) {
            for (var j = this.instances[i].length - 1; j >= 0; j--) {
                if (this.instances[i][j].is_active) {
                    this.instances[i][j].pre_update();
                    if (this.instances[i][j])
                        this.instances[i][j].update();
                    if (this.instances[i][j])
                        this.instances[i][j].post_update();
                }
                else {
                    this.instances[i][j].inactive_update();
                }
            }
        }
    },
    render_all: function () {
        var h = [];
        for (var i = this.instances.length - 1; i >= 0; i--) {
            for (var j = this.instances[i].length - 1; j >= 0; j--) {
                if (this.instances[i][j].is_visible) {
                    h.push(this.instances[i][j]);
                }
            }
        }
        h.sort(function (a, b) { return a.depth - b.depth; });
        for (var i = h.length - 1; i >= 0; i--) {
            h[i].render();
        }
    },
    render_ui_all: function () {
        var h = [];
        for (var i = this.instances.length - 1; i >= 0; i--) {
            for (var j = this.instances[i].length - 1; j >= 0; j--) {
                if (this.instances[i][j].is_visible) {
                    h.push(this.instances[i][j]);
                }
            }
        }
        h.sort(function (a, b) { return a.depth - b.depth; });
        for (var i = h.length - 1; i >= 0; i--) {
            h[i].render_ui();
        }
    },
    instantiate: function (name, n) {
        this.instances[this.get_index(name)].push(n);
        n.id = this._ID++;
        n.start();
        return n;
    },
    take: function () {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        var h = [];
        for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {
            var name_1 = names_1[_a];
            h = h.concat(this.instances[this.get_index(name_1)]);
        }
        return h;
    },
    get: function (id) {
        for (var i = this.instances.length - 1; i >= 0; i--) {
            for (var j = this.instances[i].length - 1; j >= 0; j--) {
                if (this.instances[i][j].id === id) {
                    return this.instances[i][j];
                }
            }
        }
        return null;
    },
    remove: function (id) {
        for (var i = this.instances.length - 1; i >= 0; i--) {
            for (var j = this.instances[i].length - 1; j >= 0; j--) {
                if (this.instances[i][j].id === id) {
                    return this.instances[i].splice(j, 1)[0];
                }
            }
        }
        return null;
    },
    nearest: function (name, x, y) {
        var l = -1;
        var m = null;
        for (var _i = 0, _a = this.instances[this.get_index(name)]; _i < _a.length; _i++) {
            var n = _a[_i];
            var o = Math.hypot(n.x - x, n.y - y);
            if (l < 0 || o < l) {
                m = n;
                l = o;
            }
        }
        return m;
    },
};
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CoreView = (function (_super) {
    __extends(CoreView, _super);
    function CoreView() {
        var _this = _super.call(this, 0, 0) || this;
        _this.position = new CoreVec2();
        _this.target_position = new CoreVec2();
        _this.is_shaking = false;
        _this.shake_timer = 0;
        _this.shake_duration = 1000;
        _this.shake_strength = 2;
        _this.shake_offset = new CoreVec2();
        _this.offset_position = new CoreVec2();
        return _this;
    }
    CoreView.prototype.set_target_position = function (v) {
        this.target_position.set(v);
    };
    CoreView.prototype.update = function () {
        this.position.lerp_to(this.target_position, 0.2 * time.scaled_dt);
        if (this.is_shaking) {
            if (this.shake_timer <= 0) {
                this.is_shaking = false;
                this.shake_offset.reset();
            }
            else {
                this.shake_timer -= time.dt;
                var shake_timer_scalar = this.shake_timer / this.shake_duration;
                var strength = this.shake_strength * shake_timer_scalar;
                this.shake_offset.x = strength * (-1 + 2 * Math.random());
                this.shake_offset.y = strength * (-1 + 2 * Math.random());
            }
            this.offset_position.set(this.position).add(this.shake_offset);
        }
    };
    CoreView.prototype.post_update = function () {
        this.x = this.position.x;
        this.y = this.position.y;
    };
    CoreView.prototype.shake = function (duration, strength) {
        this.shake_duration = duration;
        this.shake_strength = strength;
        this.shake_timer = this.shake_duration;
        this.is_shaking = true;
    };
    CoreView.instantiate_view = function () {
        return core.obj.instantiate('core_view', new CoreView());
    };
    return CoreView;
}(CoreObject));
core.obj.add_name('core_view');
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CoreParticle = (function () {
    function CoreParticle(x, y, life) {
        this.speed = 0;
        this.speed_inc = 0;
        this.direction_rad = 0;
        this.direction_rad_inc = 0;
        this.size = 0;
        this.size_end = 0;
        this.color = '';
        this.fade_out = 0;
        this.vx = 0;
        this.vy = 0;
        this.grav = 0.5;
        this.fric = 0.99;
        this.life_start = 0;
        this.life_scaled = 1;
        this.x = x;
        this.y = y;
        this.life = life;
        this.life_start = this.life;
    }
    CoreParticle.prototype.update = function () {
        this.life -= time.dt;
        this.life_scaled = Math.min(1, Math.max(0, this.life / this.life_start));
        if (this.life <= 0) {
            return false;
        }
        this.speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        this.direction_rad = Math.atan2(this.vy, this.vx);
        this.speed += this.speed_inc * time.scaled_dt;
        this.direction_rad += this.direction_rad_inc * time.scaled_dt;
        this.vx = Math.cos(this.direction_rad) * this.speed;
        this.vy = Math.sin(this.direction_rad) * this.speed;
        this.vy += this.grav * time.scaled_dt;
        this.vx *= this.fric;
        this.vy *= this.fric;
        this.x += this.vx * time.scaled_dt;
        this.y += this.vy * time.scaled_dt;
        return true;
    };
    CoreParticle.prototype.render = function () {
        draw.set_color(this.color);
        draw.ctx.globalAlpha = this.fade_out === 0 ? 1 : Math.min(1, this.life / this.fade_out);
        draw.circle(this.x, this.y, this.size * 0.5 * (1 - (1 - this.size_end) * (1 - this.life_scaled)));
        draw.ctx.globalAlpha = 1;
    };
    return CoreParticle;
}());
var CoreEmitter = (function (_super) {
    __extends(CoreEmitter, _super);
    function CoreEmitter() {
        var _this = _super.call(this, 0, 0) || this;
        _this.list = [];
        _this.life = {
            min: 2000,
            max: 3000,
        };
        _this.area = {
            x: 0,
            y: 0,
            w: 300,
            h: 0,
        };
        _this.grav = {
            min: 0.5,
            max: 0.5,
        };
        _this.fric = {
            min: 0.99,
            max: 0.99,
        };
        _this.speed = {
            min: 15,
            max: 18,
        };
        _this.speed_inc = {
            min: -0.5,
            max: 0.5,
        };
        _this.direction_rad = {
            min: 0,
            max: Math.PI,
        };
        _this.direction_rad_inc = {
            min: -0.1,
            max: 0.1,
        };
        _this.size = {
            min: 10,
            max: 25,
        };
        _this.size_end = {
            min: 0.1,
            max: 0.2,
        };
        _this.colors = ['skyblue', 'royalblue', 'gold'];
        _this.fade_out = {
            min: 0.2,
            max: 0.4,
        };
        return _this;
    }
    CoreEmitter.range = function (min, max) {
        return min + Math.random() * (max - min);
    };
    CoreEmitter.prototype.reset = function (life_min, life_max, grav_min, grav_max, fric_min, fric_max, speed_min, speed_max, speed_inc_min, speed_inc_max, direction_deg_min, direction_deg_max, direction_deg_inc_min, direction_deg_inc_max, size_min, size_max, size_end_min, size_end_max, colors, fade_out_min, fade_out_max) {
        if (life_min === void 0) { life_min = 1000; }
        if (life_max === void 0) { life_max = 1000; }
        if (grav_min === void 0) { grav_min = 0; }
        if (grav_max === void 0) { grav_max = 0; }
        if (fric_min === void 0) { fric_min = 1; }
        if (fric_max === void 0) { fric_max = 1; }
        if (speed_min === void 0) { speed_min = 10; }
        if (speed_max === void 0) { speed_max = 10; }
        if (speed_inc_min === void 0) { speed_inc_min = 10; }
        if (speed_inc_max === void 0) { speed_inc_max = 10; }
        if (direction_deg_min === void 0) { direction_deg_min = 0; }
        if (direction_deg_max === void 0) { direction_deg_max = 0; }
        if (direction_deg_inc_min === void 0) { direction_deg_inc_min = 0; }
        if (direction_deg_inc_max === void 0) { direction_deg_inc_max = 0; }
        if (size_min === void 0) { size_min = 20; }
        if (size_max === void 0) { size_max = 20; }
        if (size_end_min === void 0) { size_end_min = 0.1; }
        if (size_end_max === void 0) { size_end_max = 0.1; }
        if (colors === void 0) { colors = ['white']; }
        if (fade_out_min === void 0) { fade_out_min = 0.5; }
        if (fade_out_max === void 0) { fade_out_max = 0.5; }
        this.set_life(life_min, life_max);
        this.set_grav(grav_min, grav_max);
        this.set_fric(fric_min, fric_max);
        this.set_speed(speed_min, speed_max);
        this.set_speed_inc(speed_inc_min, speed_inc_max);
        this.set_direction_deg(direction_deg_min, direction_deg_max);
        this.set_direction_deg_inc(direction_deg_inc_min, direction_deg_inc_max);
        this.set_size(size_min, size_max);
        this.set_size_end(size_end_min, size_end_max);
        this.colors = colors;
        this.set_fade_out(fade_out_min, fade_out_max);
    };
    CoreEmitter.prototype.emit = function (min, max) {
        var n = Math.round(CoreEmitter.range(min, (typeof max === 'undefined' ? min : max)));
        while (n-- > 0) {
            var p = new CoreParticle(CoreEmitter.range(this.area.x, this.area.x + this.area.w), CoreEmitter.range(this.area.y, this.area.y + this.area.h), CoreEmitter.range(this.life.min, this.life.max));
            p.speed = CoreEmitter.range(this.speed.min, this.speed.max);
            p.speed_inc = CoreEmitter.range(this.speed_inc.min, this.speed_inc.max);
            p.direction_rad = CoreEmitter.range(this.direction_rad.min, this.direction_rad.max);
            p.direction_rad_inc = CoreEmitter.range(this.direction_rad_inc.min, this.direction_rad_inc.max);
            p.size = CoreEmitter.range(this.size.min, this.size.max);
            p.size_end = CoreEmitter.range(this.size_end.min, this.size_end.max);
            p.color = this.colors[Math.floor(Math.random() * this.colors.length)];
            p.fade_out = CoreEmitter.range(this.fade_out.min, this.fade_out.max);
            p.vx = Math.cos(p.direction_rad) * p.speed;
            p.vy = Math.sin(p.direction_rad) * p.speed;
            p.grav = CoreEmitter.range(this.grav.min, this.grav.max);
            p.fric = CoreEmitter.range(this.fric.min, this.fric.max);
            this.list.push(p);
        }
    };
    CoreEmitter.prototype.update = function () {
        for (var i = this.list.length - 1; i >= 0; i--) {
            if (!this.list[i].update())
                this.list.splice(i, 1);
        }
    };
    CoreEmitter.prototype.render = function () {
        for (var i = this.list.length - 1; i >= 0; i--) {
            this.list[i].render();
        }
    };
    CoreEmitter.prototype.set_life = function (min, max) {
        this.life.min = min;
        this.life.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_area = function (x, y, w, h) {
        if (w === void 0) { w = 0; }
        if (h === void 0) { h = 0; }
        this.area.x = x;
        this.area.y = y;
        this.area.w = w;
        this.area.h = h;
    };
    CoreEmitter.prototype.set_grav = function (min, max) {
        this.grav.min = min;
        this.grav.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_fric = function (min, max) {
        this.fric.min = min;
        this.fric.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_speed = function (min, max) {
        this.speed.min = min;
        this.speed.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_speed_inc = function (min, max) {
        this.speed_inc.min = min;
        this.speed_inc.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_direction_rad = function (min, max) {
        this.direction_rad.min = min;
        this.direction_rad.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_direction_rad_inc = function (min, max) {
        this.direction_rad_inc.min = min;
        this.direction_rad_inc.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_direction_deg = function (min, max) {
        this.direction_rad.min = min * CoreEmitter.DEG_TO_RAD;
        this.direction_rad.max = (typeof max === 'undefined' ? min : max) * CoreEmitter.DEG_TO_RAD;
    };
    CoreEmitter.prototype.set_direction_deg_inc = function (min, max) {
        this.direction_rad_inc.min = min * CoreEmitter.DEG_TO_RAD;
        this.direction_rad_inc.max = (typeof max === 'undefined' ? min : max) * CoreEmitter.DEG_TO_RAD;
    };
    CoreEmitter.prototype.set_size = function (min, max) {
        this.size.min = min;
        this.size.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_size_end = function (min, max) {
        this.size_end.min = min;
        this.size_end.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.prototype.set_colors = function () {
        var colors = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            colors[_i] = arguments[_i];
        }
        this.colors = colors;
    };
    CoreEmitter.prototype.set_fade_out = function (min, max) {
        this.fade_out.min = min;
        this.fade_out.max = (typeof max === 'undefined' ? min : max);
    };
    CoreEmitter.instantiate_emitter = function () {
        return core.obj.instantiate('core_emitter', new CoreEmitter());
    };
    CoreEmitter.DEG_TO_RAD = Math.PI / 180;
    return CoreEmitter;
}(CoreObject));
core.obj.add_name('core_emitter');
"use strict";
core.debug = {
    debug_index: 0,
    debug_number: 4,
    is_debug_odd: function () {
        return this.debug_index % 2 !== 0;
    },
    is_debug_even: function () {
        return this.debug_index % 2 === 0;
    },
    update: function () {
        if (core.input.key_down('KeyU')) {
            this.debug_index = ++this.debug_index % this.debug_number;
        }
    }
};
"use strict";
core.runner = {
    is_running: false,
    step: function (t) {
        if (t === void 0) { t = 0; }
        core.debug.update();
        core.time.update(t);
        core.scene.update();
        if (!core.scene.current_scene.is_obj_update_disabled) {
            core.obj.update_all();
        }
        if (core.scene.current_scene.is_auto_clear_stage) {
            core.stage.clear();
        }
        core.scene.render();
        if (!core.scene.current_scene.is_obj_render_disabled) {
            core.obj.render_all();
            core.obj.render_ui_all();
        }
        core.scene.render_ui();
        core.input.reset();
    },
    run: function () {
        var _this = this;
        var callback = function (t) {
            _this.step(t);
            if (_this.is_running) {
                window.requestAnimationFrame(callback);
            }
        };
        this.is_running = true;
        window.requestAnimationFrame(callback);
    },
    stop: function () {
        this.is_running = false;
    },
};
"use strict";
core.loader = {
    _is_loaded: false,
    load_amount: 0,
    loaded_count: 0,
    get_is_loaded: function () {
        return this._is_loaded ? true : this.loaded_count === this.load_amount;
    },
    get_load_progress: function () {
        return this.load_amount < 1 ? 1 : this.loaded_count / this.load_amount;
    },
    set_image_load_event: function (img) {
        var _this = this;
        this.load_amount++;
        img.addEventListener('load', function () {
            _this.loaded_count++;
            if (_this.loaded_count >= _this.load_amount) {
                _this._is_loaded = true;
            }
        });
    },
    load_image: function (origin, name, src) {
        var img = new Image();
        img.src = src;
        core.draw.add_image(origin, name, img);
        this.set_image_load_event(img);
    },
    load_strip: function (origin, name, src, image_number, image_per_row) {
        if (image_per_row === void 0) { image_per_row = 0; }
        image_per_row = image_per_row || image_number;
        var img = new Image();
        img.src = src;
        core.draw.add_strip(origin, name, img, image_number, image_per_row);
        this.set_image_load_event(img);
    },
};
"use strict";
core.stage.setup();
core.setup = function (title, canvas_parent, starting_scene) {
    document.title = title;
    canvas_parent.appendChild(core.stage.canvas);
    document.addEventListener('DOMContentLoaded', function () {
        core.stage.resize_event();
    });
    core.input.setup();
    core.scene.change_scene(starting_scene);
};
"use strict";
var stage = core.stage, input = core.input, time = core.time, draw = core.draw, scene = core.scene, obj = core.obj, debug = core.debug, runner = core.runner, loader = core.loader;
"use strict";
var font = {
    s: new CoreFont(16, 'bold', 'Lato'),
    m: new CoreFont(24, 'bold', 'Lato'),
    l: new CoreFont(48, 'bold', 'Lato'),
};
"use strict";
var Alarm = (function () {
    function Alarm(default_interval, is_auto_start) {
        if (is_auto_start === void 0) { is_auto_start = true; }
        this.callbacks = [];
        this.tick = -1;
        this.default_interval = default_interval;
        if (is_auto_start) {
            this.tick = this.default_interval;
        }
    }
    Alarm.prototype.on_alarm = function (callback) {
        this.callbacks.push(callback);
    };
    Alarm.prototype.restart = function () {
        this.tick = this.default_interval;
    };
    Alarm.prototype.update = function () {
        if (this.tick < 0 && this.tick !== -1) {
            for (var i = 0; i < this.callbacks.length; i++) {
                this.callbacks[i].call(this);
            }
            this.tick = -1;
        }
        else {
            this.tick -= time.dt;
        }
    };
    return Alarm;
}());
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HeartNode = (function (_super) {
    __extends(HeartNode, _super);
    function HeartNode(name, x, y, size, vec_polar, color) {
        var _this = _super.call(this, x, y) || this;
        _this.color = 'red';
        _this.recorded_amplitude = [0];
        _this.name = name;
        _this.size = size;
        _this.circle_mask_r = _this.size;
        _this.vec_polar = vec_polar;
        if (color)
            _this.color = color;
        return _this;
    }
    HeartNode.prototype.intersect_circle = function (x, y, r) {
        return Math.hypot(this.x - x, this.y - y) < this.circle_mask_r + r;
    };
    HeartNode.prototype.intersect_vec_polar = function (x, y, distance_tolerance) {
        if (distance_tolerance === void 0) { distance_tolerance = 12; }
        return Math.hypot(this.x + this.vec_polar.x - x, this.y + this.vec_polar.y - y) < distance_tolerance;
    };
    HeartNode.prototype.render = function () {
        draw.set_color('#adbad7');
        draw.circle(this.x, this.y, this.size);
        draw.set_color(this.color);
        var arrow_end = {
            x: this.x + this.vec_polar.x,
            y: this.y + this.vec_polar.y,
        };
        draw.circle(this.x, this.y, this.size * 0.5);
        draw.ctx.lineWidth = 4;
        draw.ctx.lineCap = 'round';
        draw.ctx.lineJoin = 'round';
        draw.line(this.x, this.y, arrow_end.x, arrow_end.y);
        for (var i = 0; i < 2; i++) {
            var arrow_point_angle = 60;
            var arrow_point_length = 20;
            var arrow_point_polar = CoreVec2.polar(arrow_point_length, 180 + this.vec_polar.get_direction_deg() - arrow_point_angle / 2 + arrow_point_angle * i);
            draw.line(arrow_end.x, arrow_end.y, arrow_end.x + arrow_point_polar.x, arrow_end.y + arrow_point_polar.y);
        }
    };
    HeartNode.prototype.render_ui = function () {
        var name_text = "".concat(this.name);
        draw.set_font(font.m);
        var name_text_width = draw.get_text_width(name_text);
        var name_text_height = draw.get_text_height(name_text);
        draw.set_hvalign('center', 'bottom');
        draw.set_color(this.color);
        draw.text(this.x, this.y - this.size - 2, name_text);
        draw.set_font(font.s);
        draw.set_hvalign('left', 'middle');
        draw.text(this.x + name_text_width / 2 + 2, this.y - this.size - 2 - name_text_height, "(".concat(Math.round(this.vec_polar.get_length() / grid_size * 100) / 100, ", ").concat(Math.round(this.vec_polar.get_direction_deg()), "\u00B0)"));
    };
    HeartNode.prototype.draw_ekg_box = function (target_node, x, y, w, h) {
        draw.ctx.lineWidth = 2;
        draw.set_color('white');
        draw.rect(x, y, w, h, true);
        this.recorded_amplitude.push(Math.round(this.vec_polar.dot(target_node.vec_polar) / grid_size / 100) / 10 * target_node.vec_polar.get_length());
        if (this.recorded_amplitude.length > 10) {
            this.recorded_amplitude.shift();
        }
        draw.set_font(font.m);
        draw.set_hvalign('left', 'bottom');
        draw.text(x + 2, y + h - 2, "".concat(Math.round(this.recorded_amplitude[this.recorded_amplitude.length - 1])));
        draw.ctx.beginPath();
        draw.ctx.moveTo(x, y + h / 2 - this.recorded_amplitude[0]);
        for (var i = 1; i < this.recorded_amplitude.length; i++) {
            draw.ctx.lineTo(x + i * w / 9, y + h / 2 - this.recorded_amplitude[i]);
        }
        console.log(this.recorded_amplitude);
        draw.ctx.stroke();
    };
    return HeartNode;
}(CoreObject));
obj.add_name('heart_node');
"use strict";
var scene_loading = new CoreScene();
scene_loading.start = function () {
};
scene_loading.render = function () {
    draw.set_font(font.l, { style: 'bold' });
    draw.set_hvalign('center', 'middle');
    draw.set_color('white');
    draw.text(stage.mid.w, stage.mid.h, 'LOADING');
    draw.rect(0, stage.h - 16, stage.w * loader.get_load_progress(), 16);
    if (loader.get_is_loaded()) {
        scene.change_scene(scene_game);
    }
};
"use strict";
var scene_menu = new CoreScene();
var smoke_emitter = CoreEmitter.instantiate_emitter();
smoke_emitter.reset(6000, 8000, 0, 0, 1, 1, 6, 7, 0.01, 0.02, -90, -90, -0.1, 0.1, 20, 50, 0, 0, ['#fff', '#fefefe', '#f5f5f5'], 1, 1);
scene_menu.update = function () {
    if (input.mouse_down(0)) {
        scene.change_scene(scene_game);
    }
    smoke_emitter.set_area(0, stage.h + 100, stage.w, 200);
    smoke_emitter.emit(1);
};
scene_menu.render_ui = function () {
    draw.set_font(font.m, { style: 'bold' });
    draw.set_hvalign('center', 'middle');
    draw.set_color('white');
    draw.text(stage.mid.w, stage.mid.h, 'CLICK TO START');
    draw_debug();
};
var draw_debug = function () {
    if (debug.is_debug_odd())
        return;
    draw.set_color('white');
    draw.set_font(font.m, { size: 12, style: '', family: 'Manrope' });
    draw.set_hvalign('center', 'bottom');
    draw.text(stage.mid.w, stage.h - 10, "FPS: ".concat(Math.round(time.fps)));
};
"use strict";
var grid_size = 64;
var scene_game = new CoreScene();
var selected_node = null;
var selected_node_offset = new CoreVec2();
var sa_node = null;
var main_lead = null;
scene_game.start = function () {
    sa_node = obj.instantiate('heart_node', new HeartNode('NSA', stage.mid.w, stage.mid.h, 20, CoreVec2.polar(120, 60), '#ffb814'));
    main_lead = obj.instantiate('heart_node', new HeartNode('Lead', stage.mid.w, stage.mid.h, 16, CoreVec2.polar(120, 60), '#ba3c84'));
};
scene_game.update = function () {
    if (selected_node) {
        if (input.mouse_hold(0)) {
            selected_node.x = selected_node_offset.x + input.x;
            selected_node.y = selected_node_offset.y + input.y;
        }
        if (input.mouse_up(0)) {
            selected_node = null;
        }
    }
    else {
        if (input.mouse_down(0)) {
            for (var _i = 0, _a = obj.take('heart_node'); _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.intersect_circle(input.x, input.y, 1)) {
                    selected_node = node;
                    selected_node_offset.reset();
                    break;
                }
                if (node.intersect_vec_polar(input.x, input.y)) {
                    selected_node = node.vec_polar;
                    selected_node_offset.set(-node.x, -node.y);
                    break;
                }
            }
        }
    }
};
scene_game.render = function () {
    var grid_column = stage.w / grid_size;
    var grid_row = stage.h / grid_size;
    draw.ctx.lineWidth = 5;
    draw.set_color('#1e1357');
    for (var i = 0; i < grid_column; i++) {
        var x = i * grid_size;
        draw.line(x, 0, x, stage.h);
    }
    for (var j = 0; j < grid_row; j++) {
        var y = j * grid_size;
        draw.line(0, y, stage.w, y);
    }
};
scene_game.render_ui = function () {
    if (main_lead && sa_node) {
        main_lead.draw_ekg_box(sa_node, stage.w - grid_size * 6.5, stage.mid.h - grid_size * 2.5, grid_size * 6, grid_size * 5);
    }
    draw_debug();
};
"use strict";
core.setup('EKG Sim', document.body, scene_loading);
runner.run();

</script>
</body>

</html>